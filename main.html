<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto & Forex Alerts Dashboard</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Keep existing HTML structure -->
  <div class="token-section">
    <h2>GFM Alerts</h2>
    <div class="price-container">
      <p>Buy Alert: <span id="gfm-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell Alert: <span id="gfm-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

  <div class="token-section">
    <h2>Alpha Alerts</h2>
    <div class="price-container">
      <p>Buy Alert: <span id="alpha-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell Alert: <span id="alpha-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

  <div class="token-section">
    <h2>Stonks Alerts</h2>
    <div class="price-container">
      <p>Buy Alert: <span id="stonks-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell Alert: <span id="stonks-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

  <div class="token-section">
    <h2>VVV Alerts</h2>
    <div class="price-container">
      <p>Buy Alert: <span id="vvv-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell Alert: <span id="vvv-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

  <div class="token-section">
    <h2>EUR/USD Alerts</h2>
    <div class="price-container">
      <p>Buy (DEX vs Forex): <span id="eur-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell (DEX vs Forex): <span id="eur-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

<script>
const tokens = {
  gfm: {
    type: 'jup',
    mexcApiUrl: 'https://contract.mexc.com/api/v1/contract/depth/GFM_USDT',
    jupConfig: {
      inputMintUSDC: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      outputMint: 'E1jCTXdkMRoawoWoqfbhiNkkLbxcSHPssMo36U84pump',
      buySwap: { amount: 300, decimals: 6 },
      sellSwap: { amount: 5000, decimals: 6 }
    },
    elements: {
      buy: document.getElementById('gfm-buy-alert'),
      sell: document.getElementById('gfm-sell-alert')
    }
  },
  alpha: {
    type: 'jup',
    mexcApiUrl: 'https://contract.mexc.com/api/v1/contract/depth/ALPHAOFSOL_USDT',
    jupConfig: {
      inputMintUSDC: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      outputMint: '2sCUCJdVkmyXp4dT8sFaA9LKgSMK4yDPi9zLHiwXpump',
      buySwap: { amount: 600, decimals: 6 },
      sellSwap: { amount: 5500, decimals: 6 }
    },
    elements: {
      buy: document.getElementById('alpha-buy-alert'),
      sell: document.getElementById('alpha-sell-alert')
    },
    thresholds: {
      positive: [0.001, 0.002, 0.003],
      negative: [-0.001, -0.002, -0.003]
    }
  },
  stonks: {
    type: 'jup',
    mexcApiUrl: 'https://contract.mexc.com/api/v1/contract/depth/STONKS_USDT',
    jupConfig: {
      inputMintUSDC: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      outputMint: '6NcdiK8B5KK2DzKvzvCfqi8EHaEqu48fyEzC8Mm9pump',
      buySwap: { amount: 300, decimals: 6 },
      sellSwap: { amount: 8500, decimals: 6 }
    },
    elements: {
      buy: document.getElementById('stonks-buy-alert'),
      sell: document.getElementById('stonks-sell-alert')
    },
    thresholds: {
      positive: [0.003, 0.006, 0.009],
      negative: [-0.003, -0.006, -0.009]
    }
  },
  // ... rest of existing tokens ...
  vvv: {
    type: 'kyber',
    mexcApiUrl: 'https://contract.mexc.com/api/v1/contract/depth/VVV_USDT',
    kyberConfig: {
      USDC_ADDRESS: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
      TOKEN_ADDRESS: '0xacfE6019Ed1A7Dc6f7B508C02d1b04ec88cC21bf',
      buyAmount: 900,
      sellAmount: 100
    },
    elements: {
      buy: document.getElementById('vvv-buy-alert'),
      sell: document.getElementById('vvv-sell-alert')
    },
    thresholds: {
      positive: [0.1, 0.2, 0.3],
      negative: [-0.1, -0.2, -0.3]
    }
  },
  eur: {
    type: 'forex',
    kyberConfig: {
      USDC_ADDRESS: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
      EURC_ADDRESS: '0x9C58C6fA20b6AA2B8d5705f0F201eA36aD4D7b3c',
      buyAmount: 1000,
      sellAmount: 1000
    },
    elements: {
      buy: document.getElementById('eur-buy-alert'),
      sell: document.getElementById('eur-sell-alert')
    }
  }
};

async function fetchMexcPrice(apiUrl) {
  try {
    const proxyUrl = 'https://api.codetabs.com/v1/proxy/?quest=';
    const response = await fetch(proxyUrl + apiUrl);
    const data = await response.json();
    
    if (!data?.data?.bids?.[0]?.[0] || !data?.data?.asks?.[0]?.[0]) {
      throw new Error('Invalid MEXC response');
    }
    
    return {
      bid: parseFloat(data.data.bids[0][0]),
      ask: parseFloat(data.data.asks[0][0])
    };
  } catch (error) {
    console.error(`MEXC Error (${apiUrl}):`, error);
    return null;
  }
}

async function fetchJupSwapPrice(inputMint, outputMint, amount, decimals) {
  try {
    const url = `https://quote-api.jup.ag/v6/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}`;
    const response = await fetch(url);
    
    if (!response.ok) throw new Error(`JUP API Error: ${response.status}`);
    
    const data = await response.json();
    return data.outAmount / 10 ** decimals;
  } catch (error) {
    console.error('JUP Swap Error:', error);
    return null;
  }
}

async function fetchKyberSwapPrice(inputToken, outputToken, amount) {
  try {
    const amountIn = amount.toLocaleString('fullwide', { useGrouping: false });
    const KYBER_ROUTER = '0x6131B5fae19EA4f9D964eAc0408E4408b66337b5';
    const url = `https://aggregator-api.kyberswap.com/base/api/v1/routes?tokenIn=${inputToken}&tokenOut=${outputToken}&amountIn=${amountIn}&to=${KYBER_ROUTER}`;
    
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Kyber API Error: ${response.status}`);
    
    const data = await response.json();
    return Number(data.data.routeSummary.amountOut);
  } catch (error) {
    console.error('KyberSwap Error:', error);
    return null;
  }
}

async function fetchForexRate() {
  try {
    const proxyUrl = 'https://api.codetabs.com/v1/proxy/?quest=';
    const response = await fetch(proxyUrl + 'https://api.exchangerate.host/latest?base=USD&symbols=EUR');
    const data = await response.json();
    
    if (!data?.success || !data?.rates?.EUR) {
      throw new Error('Invalid Forex API response');
    }
    
    return data.rates.EUR;
  } catch (error) {
    console.error('Forex API Error:', error);
    return null;
  }
}

async function fetchTokenPrices(tokenConfig) {
  try {
    if (tokenConfig.type === 'forex') {
      const [forexRate, kyberBuy, kyberSell] = await Promise.all([
        fetchForexRate(),
        fetchKyberSwapPrice(
          tokenConfig.kyberConfig.USDC_ADDRESS,
          tokenConfig.kyberConfig.EURC_ADDRESS,
          tokenConfig.kyberConfig.buyAmount * 1e6
        ),
        fetchKyberSwapPrice(
          tokenConfig.kyberConfig.EURC_ADDRESS,
          tokenConfig.kyberConfig.USDC_ADDRESS,
          tokenConfig.kyberConfig.sellAmount * 1e6
        )
      ]);

      if (!forexRate || !kyberBuy || !kyberSell) return null;

      const dexBuyRate = kyberBuy / (tokenConfig.kyberConfig.buyAmount * 1e6);
      const dexSellRate = kyberSell / (tokenConfig.kyberConfig.sellAmount * 1e6);
      const forexSellRate = 1 / forexRate;
      
      return {
        buyDiff: (dexBuyRate - forexRate).toFixed(5),
        sellDiff: (dexSellRate - forexSellRate).toFixed(5)
      };
    }

    const mexcPrices = await fetchMexcPrice(tokenConfig.mexcApiUrl);
    if (!mexcPrices) return null;

    if (tokenConfig.type === 'jup') {
      const [jupBuy, jupSell] = await Promise.all([
        fetchJupSwapPrice(
          tokenConfig.jupConfig.inputMintUSDC,
          tokenConfig.jupConfig.outputMint,
          tokenConfig.jupConfig.buySwap.amount * 10 ** 6,
          tokenConfig.jupConfig.buySwap.decimals
        ),
        fetchJupSwapPrice(
          tokenConfig.jupConfig.outputMint,
          tokenConfig.jupConfig.inputMintUSDC,
          tokenConfig.jupConfig.sellSwap.amount * 10 ** tokenConfig.jupConfig.sellSwap.decimals,
          6
        )
      ]);

      if (!jupBuy || !jupSell) return null;

      return {
        buyRate: tokenConfig.jupConfig.buySwap.amount / jupBuy,
        sellRate: jupSell / tokenConfig.jupConfig.sellSwap.amount,
        mexcBid: mexcPrices.bid,
        mexcAsk: mexcPrices.ask
      };
    }
    
    if (tokenConfig.type === 'kyber') {
      const [kyberBuy, kyberSell] = await Promise.all([
        fetchKyberSwapPrice(
          tokenConfig.kyberConfig.USDC_ADDRESS,
          tokenConfig.kyberConfig.TOKEN_ADDRESS,
          tokenConfig.kyberConfig.buyAmount * 1e6
        ),
        fetchKyberSwapPrice(
          tokenConfig.kyberConfig.TOKEN_ADDRESS,
          tokenConfig.kyberConfig.USDC_ADDRESS,
          tokenConfig.kyberConfig.sellAmount * 1e18
        )
      ]);

      if (!kyberBuy || !kyberSell) return null;

      return {
        buyRate: tokenConfig.kyberConfig.buyAmount / (kyberBuy / 1e18),
        sellRate: (kyberSell / 1e6) / tokenConfig.kyberConfig.sellAmount,
        mexcBid: mexcPrices.bid,
        mexcAsk: mexcPrices.ask
      };
    }
  } catch (error) {
    console.error(`Price fetch error (${tokenConfig.type}):`, error);
    return null;
  }
}

function applyAlertStyles(element, value, tokenKey) {
  element.className = '';
  const isPositive = value > 0;
  const absValue = Math.abs(value);

  if (tokenKey === 'alpha') {
    if (isPositive) {
      if (value >= 0.003) {
        element.classList.add('alert-flashing-2');
      } else if (value >= 0.002) {
        element.classList.add('alert-flashing-1');
      } else if (value >= 0.001) {
        element.classList.add('alert-large-green');
      } else {
        element.classList.add('alert-positive');
      }
    } else {
      if (value <= -0.003) {
        element.classList.add('alert-flashing-negative-2');
      } else if (value <= -0.002) {
        element.classList.add('alert-flashing-negative-1');
      } else if (value <= -0.001) {
        element.classList.add('alert-large-red');
      } else {
        element.classList.add('alert-negative');
      }
    }
  } else if (tokenKey === 'stonks') {
    // Corrected thresholds for Stonks
    if (isPositive) {
      if (value >= 0.009) {  // Updated from 0.0009 to 0.009
        element.classList.add('alert-flashing-2');
      } else if (value >= 0.006) {  // Updated from 0.0006 to 0.006
        element.classList.add('alert-flashing-1');
      } else if (value >= 0.003) {  // Updated from 0.0003 to 0.003
        element.classList.add('alert-large-green');
      } else {
        element.classList.add('alert-positive');
      }
    } else {
      if (value <= -0.009) {  // Updated from -0.0009 to -0.009
        element.classList.add('alert-flashing-negative-2');
      } else if (value <= -0.006) {  // Updated from -0.0006 to -0.006
        element.classList.add('alert-flashing-negative-1');
      } else if (value <= -0.003) {  // Updated from -0.0003 to -0.003
        element.classList.add('alert-large-red');
      } else {
        element.classList.add('alert-negative');
      }
    }
  } else if (tokenKey === 'vvv') {
    // Existing vvv logic remains unchanged
    if (isPositive) {
      if (value >= 0.3) {
        element.classList.add('alert-flashing-2');
      } else if (value >= 0.2) {
        element.classList.add('alert-flashing-1');
      } else if (value >= 0.1) {
        element.classList.add('alert-large-green');
      } else {
        element.classList.add('alert-positive');
      }
    } else {
      if (value <= -0.3) {
        element.classList.add('alert-flashing-negative-2');
      } else if (value <= -0.2) {
        element.classList.add('alert-flashing-negative-1');
      } else if (value <= -0.1) {
        element.classList.add('alert-large-red');
      } else {
        element.classList.add('alert-negative');
      }
    }
  } else if (tokenKey === 'gfm') {
    // New thresholds for GFM
    if (isPositive) {
      if (value >= 0.003) {
        element.classList.add('alert-flashing-2');
      } else if (value >= 0.002) {
        element.classList.add('alert-flashing-1');
      } else if (value >= 0.001) {
        element.classList.add('alert-large-green');
      } else {
        element.classList.add('alert-positive');
      }
    } else {
      if (value <= -0.003) {
        element.classList.add('alert-flashing-negative-2');
      } else if (value <= -0.002) {
        element.classList.add('alert-flashing-negative-1');
      } else if (value <= -0.001) {
        element.classList.add('alert-large-red');
      } else {
        element.classList.add('alert-negative');
      }
    }
  } else {
    // Default thresholds for other tokens (if any)
    if (absValue > 0.003) {
      element.classList.add(isPositive ? 'alert-flashing-2' : 'alert-flashing-negative-2');
    } else if (absValue > 0.002) {
      element.classList.add(isPositive ? 'alert-flashing-1' : 'alert-flashing-negative-1');
    } else if (absValue > 0.001) {
      element.classList.add(isPositive ? 'alert-large-green' : 'alert-large-red');
    } else {
      element.classList.add(isPositive ? 'alert-positive' : 'alert-negative');
    }
  }
}

async function updateTokenAlerts(tokenKey) {
  const config = tokens[tokenKey];
  try {
    const prices = await fetchTokenPrices(config);
    
    if (!prices) {
      config.elements.buy.textContent = 'Error';
      config.elements.sell.textContent = 'Error';
      return;
    }

    if (config.type === 'forex') {
      config.elements.buy.textContent = prices.buyDiff;
      config.elements.sell.textContent = prices.sellDiff;
      
      applyAlertStyles(config.elements.buy, parseFloat(prices.buyDiff), tokenKey);
      applyAlertStyles(config.elements.sell, parseFloat(prices.sellDiff), tokenKey);
      return;
    }

    const buyDiff = (prices.mexcBid - prices.buyRate).toFixed(5);
    const sellDiff = (prices.sellRate - prices.mexcAsk).toFixed(5);

    config.elements.buy.textContent = buyDiff;
    config.elements.sell.textContent = sellDiff;

    applyAlertStyles(config.elements.buy, parseFloat(buyDiff), tokenKey);
    applyAlertStyles(config.elements.sell, parseFloat(sellDiff), tokenKey);
  } catch (error) {
    console.error(`Update error (${tokenKey}):`, error);
    config.elements.buy.textContent = 'Error';
    config.elements.sell.textContent = 'Error';
  }
}

function updateAllAlerts() {
  updateTokenAlerts('gfm');
  updateTokenAlerts('alpha');
  updateTokenAlerts('stonks');
  updateTokenAlerts('vvv');
  updateTokenAlerts('eur');
}

// Initial update
updateAllAlerts();
// Update every 5 seconds
setInterval(updateAllAlerts, 7400);
</script>
</body>
</html>