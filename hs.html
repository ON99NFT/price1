<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto & Forex Alerts Dashboard</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #1a1a1a;
      color: white;
    }

    .token-section {
      background-color: #2d2d2d;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .price-container {
      margin-top: 10px;
    }

    /* Alert base styles */
    .alert-positive, .alert-negative,
    .alert-large-green, .alert-large-red,
    .alert-flashing-1, .alert-flashing-2,
    .alert-flashing-negative-1, .alert-flashing-negative-2 {
      color: white !important;
      padding: 2px 5px;
      border-radius: 3px;
      transition: background-color 0.3s ease;
    }

    /* Regular alerts */
    .alert-positive { background-color: #009900; }
    .alert-negative { background-color: #990000; }

    /* Strong alerts */
    .alert-large-green { 
        background-color: #007700;  
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 2em;
    }
    .alert-large-red { 
        background-color: #770000;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 2em;
    }

    /* Flashing alerts */
    .alert-flashing-1 {
      animation: flash-green 1s infinite;
      background-color: #009900;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 2em;
    }
    .alert-flashing-2 {
      animation: flash-green 0.5s infinite;
      background-color: #009900;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 2em;
    }
    .alert-flashing-negative-1 {
      animation: flash-red 1s infinite;
      background-color: #990000;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 2em;
    }
    .alert-flashing-negative-2 {
      animation: flash-red 0.5s infinite;
      background-color: #990000;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 2em;
    }

    @keyframes flash-green {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    @keyframes flash-red {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
  </style>
</head>
<body>

  <div class="token-section">
    <h2>Hood Alerts</h2>
    <div class="price-container">
      <p>Buy Alert: <span id="hood-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell Alert: <span id="hood-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

  <div class="token-section">
    <h2>Stonks Alerts</h2>
    <div class="price-container">
      <p>Buy Alert: <span id="stonks-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell Alert: <span id="stonks-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

  <div class="token-section">
    <h2>EUR/USD Alerts</h2>
    <div class="price-container">
      <p>Buy Alert: <span id="eurusd-buy-alert" aria-live="polite">Loading...</span></p>
      <p>Sell Alert: <span id="eurusd-sell-alert" aria-live="polite">Loading...</span></p>
    </div>
  </div>

<script>
// Audio context handling
let audioContext = null;
let audioEnabled = false;

const audioPrompt = document.createElement('div');
audioPrompt.style.position = 'fixed';
audioPrompt.style.top = '10px';
audioPrompt.style.right = '10px';
audioPrompt.style.background = '#ffcc00';
audioPrompt.style.color = 'black';
audioPrompt.style.padding = '10px';
audioPrompt.style.borderRadius = '5px';
audioPrompt.style.cursor = 'pointer';
audioPrompt.textContent = 'Click here to enable sound alerts!';
document.body.appendChild(audioPrompt);

audioPrompt.addEventListener('click', function initAudio() {
  if (audioContext) return;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioContext = new AudioContext();
    audioEnabled = true;
    console.log('Audio system ready');
    audioPrompt.style.display = 'none';
  } catch (error) {
    console.error('Audio initialization failed:', error);
    audioPrompt.textContent = 'Sound initialization failed';
  }
}, { once: true });

const tokens = {
  hood: {
    type: 'jup',
    mexcApiUrl: 'https://contract.mexc.com/api/v1/contract/depth/HOOD_USDT',
    jupConfig: {
      inputMintUSDC: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      outputMint: 'h5NciPdMZ5QCB5BYETJMYBMpVx9ZuitR6HcVjyBhood',
      buySwap: { amount: 1000, decimals: 6 },
      sellSwap: { amount: 1100000, decimals: 6 }
    },
    elements: {
      buy: document.getElementById('hood-buy-alert'),
      sell: document.getElementById('hood-sell-alert')
    },
    thresholds: {
      positive: [0.00002, 0.00004, 0.00006],
      negative: [-0.00002, -0.00004, -0.00006]
    }
  },

  eurusd: {
    type: 'kyber',
    mexcApiUrl: 'https://contract.mexc.com/api/v1/contract/depth/EUR_USD',
    kyberConfig: {
      buySwap: {
        url: 'https://aggregator-api.kyberswap.com/base/api/v1/routes',
        params: {
          tokenIn: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
          tokenOut: '0x60a3e35cc302bfa44cb288bc5a4f316fdb1adb42', // EURC on Base
          amountIn: '42000000000' // 42,000 USDC (6 decimals)
        }
      },
      sellSwap: {
        url: 'https://aggregator-api.kyberswap.com/base/api/v1/routes',
        params: {
          tokenIn: '0x60a3e35cc302bfa44cb288bc5a4f316fdb1adb42', // EURC on Base
          tokenOut: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
          amountIn: '4000000000000' // 40,000 EURC (8 decimals)
        }
      }
    },
    elements: {
      buy: document.getElementById('eurusd-buy-alert'),
      sell: document.getElementById('eurusd-sell-alert')
    },
    thresholds: {
      positive: [0.001, 0.0015, 0.002],
      negative: [-0.0005, -0.001, -0.0015]
    }
  },

  stonks: {
    type: 'jup',
    mexcApiUrl: 'https://contract.mexc.com/api/v1/contract/depth/STONKS_USDT',
    jupConfig: {
      inputMintUSDC: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      outputMint: '6NcdiK8B5KK2DzKvzvCfqi8EHaEqu48fyEzC8Mm9pump',
      buySwap: { amount: 400, decimals: 6 },
      sellSwap: { amount: 8500, decimals: 6 }
    },
    elements: {
      buy: document.getElementById('stonks-buy-alert'),
      sell: document.getElementById('stonks-sell-alert')
    },
    thresholds: {
      positive: [0.0005, 0.001, 0.0015],
      negative: [-0.0005, -0.001, -0.0015]
    }
  }
};

async function fetchMexcPrice(apiUrl) {
  try {
    const proxyUrl = 'https://api.codetabs.com/v1/proxy/?quest=';
    const response = await fetch(proxyUrl + apiUrl);
    const data = await response.json();
    
    if (!data?.data?.bids?.[0]?.[0] || !data?.data?.asks?.[0]?.[0]) {
      throw new Error('Invalid MEXC response');
    }
    
    return {
      bid: parseFloat(data.data.bids[0][0]),
      ask: parseFloat(data.data.asks[0][0])
    };
  } catch (error) {
    console.error(`MEXC Error (${apiUrl}):`, error);
    return null;
  }
}

async function fetchJupSwapPrice(inputMint, outputMint, amount, decimals) {
  try {
    const url = `https://quote-api.jup.ag/v6/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}`;
    const response = await fetch(url);
    
    if (!response.ok) throw new Error(`JUP API Error: ${response.status}`);
    
    const data = await response.json();
    return data.outAmount / 10 ** decimals;
  } catch (error) {
    console.error('JUP Swap Error:', error);
    return null;
  }
}

async function fetchKyberSwapPrice(url, params) {
  try {
    const query = new URLSearchParams(params).toString();
    const response = await fetch(`${url}?${query}`);
    const data = await response.json();
    
    if (!data?.data?.routeSummary) {
      throw new Error('Invalid KyberSwap response');
    }
    
    return data.data.routeSummary.amountOut;
  } catch (error) {
    console.error('KyberSwap Error:', error);
    return null;
  }
}

async function fetchTokenPrices(tokenConfig) {
  try {
    const mexcPrices = await fetchMexcPrice(tokenConfig.mexcApiUrl);
    if (!mexcPrices) return null;

    if (tokenConfig.type === 'jup') {
      const [jupBuy, jupSell] = await Promise.all([
        fetchJupSwapPrice(
          tokenConfig.jupConfig.inputMintUSDC,
          tokenConfig.jupConfig.outputMint,
          tokenConfig.jupConfig.buySwap.amount * 10 ** 6,
          tokenConfig.jupConfig.buySwap.decimals
        ),
        fetchJupSwapPrice(
          tokenConfig.jupConfig.outputMint,
          tokenConfig.jupConfig.inputMintUSDC,
          tokenConfig.jupConfig.sellSwap.amount * 10 ** tokenConfig.jupConfig.sellSwap.decimals,
          6
        )
      ]);

      if (!jupBuy || !jupSell) return null;

      return {
        buyRate: tokenConfig.jupConfig.buySwap.amount / jupBuy,
        sellRate: jupSell / tokenConfig.jupConfig.sellSwap.amount,
        mexcBid: mexcPrices.bid,
        mexcAsk: mexcPrices.ask
      };
    }
  } catch (error) {
    console.error(`Price fetch error (${tokenConfig.type}):`, error);
    return null;
  }
};

function playSound() {
  if (!audioContext || !audioEnabled) return;

  try {
    if (audioContext.state === 'suspended') {
      audioContext.resume().then(playSound);
      return;
    }

    // Create audio nodes
    const bufferSize = audioContext.sampleRate * 0.2;
    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    
    // Generate water-like noise
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }

    const source = audioContext.createBufferSource();
    const filter = audioContext.createBiquadFilter();
    const gain = audioContext.createGain();
    const lpFilter = audioContext.createBiquadFilter();

    // Configure filters
    filter.type = 'bandpass';
    filter.frequency.value = 1500; // Center frequency of droplet
    filter.Q.value = 15; // Resonance

    lpFilter.type = 'lowpass';
    lpFilter.frequency.value = 4000;

    // Create droplet envelope
    const now = audioContext.currentTime;
    gain.gain.setValueAtTime(0.4, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);

    // Create pitch modulation
    const pitchEnv = audioContext.createGain();
    source.detune.setValueAtTime(-1200, now);
    pitchEnv.gain.setValueAtTime(1200, now);
    pitchEnv.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    // Connect nodes
    source.buffer = noiseBuffer;
    source.connect(filter);
    filter.connect(lpFilter);
    lpFilter.connect(pitchEnv);
    pitchEnv.connect(source.detune);
    lpFilter.connect(gain);
    gain.connect(audioContext.destination);

    // Play and clean up
    source.start();
    source.stop(now + 0.4);

    setTimeout(() => {
      source.disconnect();
      filter.disconnect();
      gain.disconnect();
      lpFilter.disconnect();
      pitchEnv.disconnect();
    }, 500);

  } catch (error) {
    console.error('Water drop sound error:', error);
  }
}

function handleSoundTrigger(element) {
  const flashingClasses = [
    'alert-flashing-1', 'alert-flashing-2',
    'alert-flashing-negative-1', 'alert-flashing-negative-2'
  ];

  const currentClass = element.className.split(' ')
    .find(cls => flashingClasses.includes(cls));
  const lastClass = element.dataset.lastSoundClass;

  if (currentClass !== lastClass) {
    element.dataset.lastSoundClass = currentClass || '';
    if (currentClass) {
      const isPositive = currentClass.includes('flash-green');
      const level = currentClass.includes('2') ? 2 : 1;
      playSound(isPositive, level);
    }
  }
}

function applyAlertStyles(element, value, tokenKey) {
  element.className = '';
  const isPositive = value > 0;
  const absValue = Math.abs(value);

  if (tokenKey === 'stonks') {
    if (isPositive) {
      if (absValue >= 0.0015) element.classList.add('alert-flashing-2');
      else if (absValue >= 0.001) element.classList.add('alert-flashing-1');
      else if (absValue >= 0.0005) element.classList.add('alert-large-green');
      else element.classList.add('alert-positive');
    } else {
      if (absValue >= 0.0015) element.classList.add('alert-flashing-negative-2');
      else if (absValue >= 0.001) element.classList.add('alert-flashing-negative-1');
      else if (absValue >= 0.0005) element.classList.add('alert-large-red');
      else element.classList.add('alert-negative');
    }
  } else if (tokenKey === 'hood') {
    if (isPositive) {
      if (absValue >= 0.00006) element.classList.add('alert-flashing-2');
      else if (absValue >= 0.00004) element.classList.add('alert-flashing-1');
      else if (absValue >= 0.00002) element.classList.add('alert-large-green');
      else element.classList.add('alert-positive');
    } else {
      if (absValue >= 0.00006) element.classList.add('alert-flashing-negative-2');
      else if (absValue >= 0.00004) element.classList.add('alert-flashing-negative-1');
      else if (absValue >= 0.00002) element.classList.add('alert-large-red');
      else element.classList.add('alert-negative');
    }
  } else {
    if (isPositive) {
      if (absValue >= 0.003) element.classList.add('alert-flashing-2');
      else if (absValue >= 0.002) element.classList.add('alert-flashing-1');
      else if (absValue >= 0.001) element.classList.add('alert-large-green');
      else element.classList.add('alert-positive');
    } else {
      if (absValue >= 0.003) element.classList.add('alert-flashing-negative-2');
      else if (absValue >= 0.002) element.classList.add('alert-flashing-negative-1');
      else if (absValue >= 0.001) element.classList.add('alert-large-red');
      else element.classList.add('alert-negative');
    }
  }

  handleSoundTrigger(element);
}

async function updateTokenAlerts(tokenKey) {
  const config = tokens[tokenKey];
  try {
    const prices = await fetchTokenPrices(config);
    
    if (!prices) {
      config.elements.buy.textContent = 'Error';
      config.elements.sell.textContent = 'Error';
      return;
    }

    const buyDiff = (prices.mexcBid - prices.buyRate).toFixed(5);
    const sellDiff = (prices.sellRate - prices.mexcAsk).toFixed(5);

    config.elements.buy.textContent = buyDiff;
    config.elements.sell.textContent = sellDiff;

    applyAlertStyles(config.elements.buy, parseFloat(buyDiff), tokenKey);
    applyAlertStyles(config.elements.sell, parseFloat(sellDiff), tokenKey);
  } catch (error) {
    console.error(`Update error (${tokenKey}):`, error);
    config.elements.buy.textContent = 'Error';
    config.elements.sell.textContent = 'Error';
  }
}

function updateAllAlerts() {
  updateTokenAlerts('hood');
  updateTokenAlerts('stonks');
}

updateAllAlerts();
setInterval(updateAllAlerts, 4700);
</script>
</body>
</html>